[{"title":"vue移动音乐app——推荐界面（一）","date":"2018-01-03T02:08:56.000Z","path":"2018/01/03/vue移动音乐app——推荐界面（一）/","text":"歌手界面 歌手界面在页面骨架上增加滑动框和下方上下滑动的热门歌单推荐 step1：数据抓取 采用jsonp JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了 step2.1：NPM安装依赖npm install jsonp step2.2：jsnop的封装很多地方会用到jsonp，把他放在common的js中。首先引入jsonp, 然后对外暴露一个jsonp方法【jsonp(url, data, option)】，我们把传给服务器的url分开，一个纯净的url，一个是后面的配置data。然后返回一个promise函数 step2.3：url的拼装把相同的配置option统一放在一起，用字符串拼接在一起 数据抓取代码： common/js/jsonp:123456789101112131415161718192021222324import originJSONP from 'jsonp' // step1：引入依赖export default function jsonp(url, data, option) &#123; url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) // step3：拼接url return new Promise((resolve, reject) =&gt; &#123; // step2：返回一个promise函数，里面调用引入的jsonp originJSONP(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;function param(data) &#123; // step3：拼接url let url = '' for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += '&amp;' + k + '=' + encodeURIComponent(value) &#125; return url ? url.substring(1) : ''&#125; base/slider/slider:1234567891011121314151617181920212223&lt;script type=\"text/ecmascript-6\"&gt; import &#123;getRecommend, getDiscList&#125; from 'api/recommend' import &#123;ERR_OK&#125; from 'api/config' export default &#123; data() &#123; return &#123; recommends: [] &#125; &#125;, created() &#123; this._getRecommend() &#125;, methods: &#123; _getRecommend() &#123; getRecommend().then((res) =&gt; &#123; if (res.code === ERR_OK) &#123; this.recommends = res.data.slider // console.log(this.recommends) &#125; &#125;) &#125; &#125;&lt;/script&gt; step2：把数据显示在滑动框中 采用better-scroll，https://ustbhuangyi.github.io/better-scroll/#/ step2.1：NPM安装依赖npm install better-scroll 滑动组件算是一个基础组件，为了便于管理，我们把slider剥离出来，单独放在一个文件夹【base文件】内，然后需要的时候【recommend.vue文件】引入即可 step2.2 创建slider.vue1234567&lt;template&gt; &lt;div class=\"slider\" ref=\"slider\"&gt; &lt;div class=\"slider-group\" ref=\"sliderGroup\"&gt; &lt;slot&gt;&lt;/slot&gt; //插槽，外部引用slider会被插入到这个插槽中 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 插槽的结构在要recommend.vue里面编写【要先引入slider这个组件】1234567&lt;slider&gt; &lt;div v-for=\"item in recommends\"&gt; // recommends使我们jsonp抓取的数据 &lt;a :href=\"item.linkUrl\"&gt; &lt;img class=\"needsclick\" @load=\"loadImage\" :src=\"item.picUrl\"&gt; &lt;/a&gt; &lt;/div&gt;&lt;/slider&gt; 然后看看js部分，首先要引入我们安装的better-scroll然后设置slider设置props，可以从外部控制这个组件有哪些属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt; import BScroll from 'better-scroll' export default &#123; props: &#123; loop: &#123; type: Boolean, default: true &#125;, autoPlay: &#123; type: Boolean, default: true &#125;, interval: &#123; type: Number, default: 4000 // 4秒滚动一次 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; // 在这里最好不要写函数，统一在mothods里面写函数，然后在此调用即可 this._setSliderWidth() this._initSlider() &#125;, 20) // setTimeout(fn, 20) 也是可以的（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。 , methods: &#123; _setSliderWidth(isResize) &#123; //Vue.js 提供了我们一个获取 DOM 对象的接口—— vm.$refs。在这里，我们通过了 this.$refs.wrapper 访问到了这个 DOM 对象 this.children = this.$refs.sliderGroup.children // 找到sliderGroup下面的子元素 let width = 0 let sliderWidth = this.$refs.slider.clientWidth // Element.clientWidth 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。 for (let i = 0; i &lt; this.children.length; i++) &#123; let child = this.children[i] addClass(child, 'slider-item') //加样式 利用封装好的方法 child.style.width = sliderWidth + 'px' //子容器的宽度都是这个sliderWidth那么宽，展示的时候只能那么大 width += sliderWidth //累加总的width &#125; if (this.loop &amp;&amp; !isResize) &#123; width += 2 * sliderWidth // 在循环时，系统会自动加上两个child【第一个和最后一个】，所以长度要相应的要加上2倍 &#125; this.$refs.sliderGroup.style.width = width + 'px' &#125;, _initSlider() &#123; this.slider = new BScoll(this.$refs.slider, &#123; // better-scroll相关配置 scrollX: true, scrollY: false, momentum: false, snap: &#123; loop: this.loop, threshold: 0.3, speed: 400 &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; step3：完善sliderstep2.1 创建dots（轮播图下面的小圆点）在mounted中初始化，在template中引用并遍历dots123&lt;div class=\"dots\"&gt; &lt;span class=\"dot\" v-for=\"(item, index) in dots\"&gt;&lt;/span&gt;&lt;/div&gt; 123_initDots() &#123; this.dots = new Array(this.children.length) //dots是定义的一个数据，初始为空数组&#125; step2.2 完善dots，选中时dots高亮在数据中初始currentPageIndex: 0，修改template中的dots标签，给他们绑定一个class1&lt;span class=\"dot\" v-for=\"(item, index) in dots\" :class=\"&#123;active: currentPageIndex === index&#125;\"&gt;&lt;/span&gt; 初始化slider时绑定一个事件’scrollEnd’123456this.slider.on('scrollEnd', () =&gt; &#123; let pageIndex = this.slider.getCurrentPage().pageX this.currentPageIndex = pageIndex&#125;) step4：实现自动滚动之前在props定义了autoplay这个属性直接在mounted中加入&amp;初始化slider时加入123if (this.autoPlay) &#123; this._play()&#125; 然后编写_play函数123456_play() &#123; clearTimeout(this.timer) this.timer = setTimeout(() =&gt; &#123; this.slider.next() &#125;, this.interval)&#125; step5：适应不同大小的窗口监听window的resize事件，重新设置sliderWidth就可以了1234567window.addEventListener('resize', () =&gt; &#123; if (!this.slider) &#123; return &#125; this._setSliderWidth(true) this.slider.refresh() // 宽度发生改变，重新刷新&#125;) 为了防止每次都要加两个sliderWidth，我们加上一个参数isResize1234567891011121314151617_setSliderWidth(isResize) &#123; this.children = this.$refs.sliderGroup.children let width = 0 let sliderWidth = this.$refs.slider.clientWidth for (let i = 0; i &lt; this.children.length; i++) &#123; let child = this.children[i] addClass(child, 'slider-item') child.style.width = sliderWidth + 'px' width += sliderWidth &#125; if (this.loop &amp;&amp; !isResize) &#123; width += 2 * sliderWidth &#125; this.$refs.sliderGroup.style.width = width + 'px'&#125; 嗒哒！！！","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"slider","slug":"slider","permalink":"http://yoursite.com/tags/slider/"}]},{"title":"vue学习笔记（二）","date":"2017-12-18T04:02:24.000Z","path":"2017/12/18/vue学习笔记（二）/","text":"Vue路由 (=ᴗ=)✧ vue路由 对于单页应用，官方提供了vue-router进行路由跳转的处理 传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。 第一个单页面应用这个单页面应用有两个路径：/home和/about，与这两个路径对应的是两个组件Home和About。 step1 创建组件首先引入vue.js和vue-router.js： 12&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"js/vue-router.js\"&gt;&lt;/script&gt; 然后创建两个组件构造器Home和About： 12345678910111213var bear = Vue.extend(&#123; template: '&lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;img src=\"bear.jpg\"&gt;&lt;/p&gt;&lt;/div&gt;', data: function() &#123; return &#123; msg: 'Hello, vue router!' &#125; &#125;&#125;);//可以简写为// var bear = &#123; template :'&lt;img src=\"bear.jpg\"&gt;'&#125;var rabbit = Vue.extend(&#123; template: '&lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;This is the tutorial about vue-router.&lt;/p&gt;&lt;img src=\"rabbit.jpg\"&gt;&lt;/div&gt;'&#125;); step2 定义Router，映射路由12345678var routes = [ &#123; path:'/bear',component:bear &#125;, &#123; path:'/rabbit',component:rabbit &#125;] 每个路由应该映射一个组件。 其中”component” 可以是通过 Vue.extend()创建的组件构造器，或者，只是一个组件配置对象。 调用router的map方法映射路由，每条路由以key-value的形式存在，key是路径，value是组件。例如：’/home’是一条路由的key，它表示路径；{component: Home}则表示该条路由映射的组件。 step3 创建 router 实例，然后传 routes 配置123var router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;) 调用router的map方法映射路由，每条路由以key-value的形式存在，key是路径，value是组件。例如：’/home’是一条路由的key，它表示路径；{component: Home}则表示该条路由映射的组件。 step4 使用v-link指令12&lt;router-link to=\"/bear\"&gt;布朗熊&lt;/router-link&gt;&lt;router-link to=\"/rabbit\"&gt;可妮兔&lt;/router-link&gt; 在a元素上使用v-link指令跳转到指定路径。 step5 使用标签123456&lt;div id=\"box\"&gt; &lt;router-link to=\"/bear\"&gt;布朗熊&lt;/router-link&gt; &lt;router-link to=\"/rabbit\"&gt;可妮兔&lt;/router-link&gt; &lt;hr&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 在页面上使用标签，它用于渲染匹配的组件。 step6 创建和挂载根实例123var app = new Vue(&#123; router&#125;).$mount('#app') //vm.$mount() 手动地挂载一个未挂载的实例 记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue应用（一）——todolist","date":"2017-12-18T03:52:30.000Z","path":"2017/12/18/vue应用（一）——todolist/","text":"","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"CI的AJAX分页","date":"2017-11-20T09:31:04.000Z","path":"2017/11/20/CI的AJAX分页/","text":"CI自带的分页不是默认的ajax，而是一次性拿回所有的数据，如果数据量很大就会反应hin慢，而CI的AJAX分页则很好的解决了这个问题~动态的一次性只拿X条数据！！！妈妈再也不用担心我的系统反应慢了！！！ step1：在controller中配置123456789101112131415161718$config['full_tag_open'] = '&lt;ul class=\"pagination\"&gt;';$config['full_tag_close'] = '&lt;/ul&gt;';$config['cur_tag_open'] = '&lt;li class=\"active\"&gt;&lt;a&gt;';//当前页的样式$config['cur_tag_close'] = '&lt;/a&gt;&lt;/li&gt;';$config['first_tag_open'] = '&lt;li&gt;';$config['first_tag_close'] = '&lt;/li&gt;';$config['last_tag_open'] = '&lt;li&gt;';$config['last_tag_close'] = '&lt;/li&gt;';$config['num_tag_open'] = '&lt;li&gt;';//数字链接的起始标签。$config['num_tag_close'] = '&lt;/li&gt;';$config['prev_tag_open'] = '&lt;li&gt;';$config['prev_tag_close'] = '&lt;/li&gt;';$config['next_tag_open'] = '&lt;li&gt;';$config['next_tag_close'] = '&lt;/li&gt;';$config['first_link'] = '首页';$config['last_link'] = '尾页';$config['prev_link'] = '上一页';$config['next_link'] = '下一页'; 如果一个页面有好几个分页，建议把这个配置封装起来 12345678910111213141516171819public function loading()&#123; $config['配置'] = '配置'; return $config;&#125;public function twitterspage($offset,$twitterID,$ci_pagination_id) &#123;$total = $this-&gt;userpage_twitter_m-&gt;getUsertwitterstotal($twitterID);//一共有多少条数据$page_size = 5; //每页显示多少条数据$config=$this-&gt;loading(); #然后在要用它的地方load进来就行$config['total_rows'] = $total;$config['per_page'] = $page_size; //每页显示条数$config['cur_page'] = $offset; //当前页$this-&gt;pagination-&gt;initialize($config);$query = $this-&gt;userpage_twitter_m-&gt;getUsertwitters($twitterID,$offset,$page_size); //获取数据$pagination = $this-&gt;pagination-&gt;create_ajax_links_1($twitterID,$ci_pagination_id); //分页设置$data['query'] = $query;$data['page'] = $pagination;$data['total'] = $total;return $data;&#125; step2：分页设置在libraries里面插入My_pagination.php，在这个php文件里面我们重写CI分页函数然后别忘了在引入这个文件123456public function __construct()&#123; parent::__construct(); $this-&gt;load-&gt;library('pagination'); $this-&gt;load-&gt;library('MY_Pagination');&#125; 一个页面中有时候会需要多个分页，为了一个分页就重写一个函数是很浪费精力的可以传入一个参数，这个参数就是在view里面调用ajax的函数名 &emsp; step3：view写相应的函数 最后附上My_pagination.php的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263class MY_Pagination extends CI_Pagination &#123; public function __construct() &#123; parent::__construct(); &#125; function create_ajax_links_0($ci_pagination_id) &#123; // If our item count or per-page total is zero there is no need to continue. // Note: DO NOT change the operator to === here! if ($this-&gt;total_rows == 0 OR $this-&gt;per_page == 0) &#123; return ''; &#125; // Calculate the total number of pages //ceil() 函数向上舍入为最接近的整数 $num_pages = (int) ceil($this-&gt;total_rows / $this-&gt;per_page); // Is there only one page? Hm... nothing more to do here then. if ($num_pages === 1) &#123; return ''; &#125; // Check the user defined number of links. $this-&gt;num_links = (int) $this-&gt;num_links; if ($this-&gt;num_links &lt; 0) &#123; show_error('Your number of links must be a non-negative number.'); &#125; // Keep any existing query string items. // Note: Has nothing to do with any other query string option. if ($this-&gt;reuse_query_string === TRUE) &#123; $get = $this-&gt;CI-&gt;input-&gt;get(); // Unset the controll, method, old-school routing options unset($get['c'], $get['m'], $get[$this-&gt;query_string_segment]); &#125; else &#123; $get = array(); &#125; // Put together our base and first URLs. // Note: DO NOT append to the properties as that would break successive calls $base_url = trim($this-&gt;base_url); $first_url = $this-&gt;first_url; $query_string = ''; $query_string_sep = (strpos($base_url, '?') === FALSE) ? '?' : '&amp;amp;'; // Are we using query strings? if ($this-&gt;page_query_string === TRUE) &#123; // If a custom first_url hasn't been specified, we'll create one from // the base_url, but without the page item. if ($first_url === '') &#123; $first_url = $base_url; // If we saved any GET items earlier, make sure they're appended. if ( ! empty($get)) &#123; $first_url .= $query_string_sep.http_build_query($get); &#125; &#125; // Add the page segment to the end of the query string, where the // page number will be appended. $base_url .= $query_string_sep.http_build_query(array_merge($get, array($this-&gt;query_string_segment =&gt; ''))); &#125; else &#123; // Standard segment mode. // Generate our saved query string to append later after the page number. if ( ! empty($get)) &#123; $query_string = $query_string_sep.http_build_query($get); $this-&gt;suffix .= $query_string; &#125; // Does the base_url have the query string in it? // If we're supposed to save it, remove it so we can append it later. if ($this-&gt;reuse_query_string === TRUE &amp;&amp; ($base_query_pos = strpos($base_url, '?')) !== FALSE) &#123; $base_url = substr($base_url, 0, $base_query_pos); &#125; if ($first_url === '') &#123; $first_url = $base_url.$query_string; &#125; $base_url = rtrim($base_url, '/').'/'; &#125; // Determine the current page number. $base_page = ($this-&gt;use_page_numbers) ? 1 : 0; // Are we using query strings? if ($this-&gt;page_query_string === TRUE) &#123; $this-&gt;cur_page = $this-&gt;CI-&gt;input-&gt;get($this-&gt;query_string_segment); &#125; elseif (empty($this-&gt;cur_page)) &#123; // Default to the last segment number if one hasn't been defined. if ($this-&gt;uri_segment === 0) &#123; $this-&gt;uri_segment = count($this-&gt;CI-&gt;uri-&gt;segment_array()); &#125; //$this-&gt;cur_page = $this-&gt;CI-&gt;uri-&gt;segment($this-&gt;uri_segment); // Remove any specified prefix/suffix from the segment. if ($this-&gt;prefix !== '' OR $this-&gt;suffix !== '') &#123; $this-&gt;cur_page = str_replace(array($this-&gt;prefix, $this-&gt;suffix), '', $this-&gt;cur_page); &#125; &#125; else &#123; $this-&gt;cur_page = (string) $this-&gt;cur_page; &#125; // If something isn't quite right, back to the default base page. if ( ! ctype_digit($this-&gt;cur_page) OR ($this-&gt;use_page_numbers &amp;&amp; (int) $this-&gt;cur_page === 0)) &#123; $this-&gt;cur_page = $base_page; &#125; else &#123; // Make sure we're using integers for comparisons later. $this-&gt;cur_page = (int) $this-&gt;cur_page; &#125; // Is the page number beyond the result range? // If so, we show the last page. if ($this-&gt;use_page_numbers) &#123; if ($this-&gt;cur_page &gt; $num_pages) &#123; $this-&gt;cur_page = $num_pages; &#125; &#125; elseif ($this-&gt;cur_page &gt; $this-&gt;total_rows) &#123; $this-&gt;cur_page = ($num_pages - 1) * $this-&gt;per_page; &#125; $uri_page_number = $this-&gt;cur_page; // If we're using offset instead of page numbers, convert it // to a page number, so we can generate the surrounding number links. if ( ! $this-&gt;use_page_numbers) &#123; $this-&gt;cur_page = (int) floor(($this-&gt;cur_page/$this-&gt;per_page) + 1); &#125; // Calculate the start and end numbers. These determine // which number to start and end the digit links with. $start = (($this-&gt;cur_page - $this-&gt;num_links) &gt; 0) ? $this-&gt;cur_page - ($this-&gt;num_links - 1) : 1; $end = (($this-&gt;cur_page + $this-&gt;num_links) &lt; $num_pages) ? $this-&gt;cur_page + $this-&gt;num_links : $num_pages; // And here we go... $output = ''; // Render the \"First\" link.【首页】 if ($this-&gt;first_link !== FALSE &amp;&amp; $this-&gt;cur_page &gt; ($this-&gt;num_links + 1 + ! $this-&gt;num_links)) &#123; // Take the general parameters, and squeeze this pagination-page attr in for JS frameworks. $attributes = sprintf('%s %s=\"%d\"', $this-&gt;_attributes, $this-&gt;data_page_attr, 1); $output .= $this-&gt;first_tag_open.'&lt;a onclick='.$ci_pagination_id.'(0,'.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes.$this-&gt;_attr_rel('start').'&gt;'.$this-&gt;first_link.'&lt;/a&gt;'.$this-&gt;first_tag_close; &#125; // Render the \"Previous\" link.【上一页】 if ($this-&gt;prev_link !== FALSE &amp;&amp; $this-&gt;cur_page !== 1) &#123; $i = ($this-&gt;use_page_numbers) ? $uri_page_number - 1 : $uri_page_number - $this-&gt;per_page; $attributes = sprintf('%s %s=\"%d\"', $this-&gt;_attributes, $this-&gt;data_page_attr, ($this-&gt;cur_page - 1)); if ($i === $base_page) &#123; // First page $output .= $this-&gt;prev_tag_open.'&lt;a onclick='.$ci_pagination_id.'(0,'.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes.$this-&gt;_attr_rel('prev').'&gt;' .$this-&gt;prev_link.'&lt;/a&gt;'.$this-&gt;prev_tag_close; &#125; else &#123; $append = $this-&gt;prefix.$i.$this-&gt;suffix; $output .= $this-&gt;prev_tag_open.'&lt;a onclick='.$ci_pagination_id.'('.$i.','.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes.$this-&gt;_attr_rel('prev').'&gt;' .$this-&gt;prev_link.'&lt;/a&gt;'.$this-&gt;prev_tag_close; &#125; &#125; // Render the pages if ($this-&gt;display_pages !== FALSE) &#123; // Write the digit links for ($loop = $start - 1; $loop &lt;= $end; $loop++) &#123; $i = ($this-&gt;use_page_numbers) ? $loop : ($loop * $this-&gt;per_page) - $this-&gt;per_page; $attributes = sprintf('%s %s=\"%d\"', $this-&gt;_attributes, $this-&gt;data_page_attr, $loop); if ($i &gt;= $base_page) &#123; if ($this-&gt;cur_page === $loop) &#123; // Current page $output .= $this-&gt;cur_tag_open.$loop.$this-&gt;cur_tag_close; &#125; elseif ($i === $base_page) &#123; // First page $output .= $this-&gt;num_tag_open.'&lt;a onclick='.$ci_pagination_id.'(0,'.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes.$this-&gt;_attr_rel('start').'&gt;' .$loop.'&lt;/a&gt;'.$this-&gt;num_tag_close; &#125; else &#123; $append = $this-&gt;prefix.$i.$this-&gt;suffix; $output .= $this-&gt;num_tag_open.'&lt;a onclick='.$ci_pagination_id.'('.$i.','.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes.'&gt;' .$loop.'&lt;/a&gt;'.$this-&gt;num_tag_close; &#125; &#125; &#125; &#125; // Render the \"next\" link【下一页】 if ($this-&gt;next_link !== FALSE &amp;&amp; $this-&gt;cur_page &lt; $num_pages) &#123; $i = ($this-&gt;use_page_numbers) ? $this-&gt;cur_page + 1 : $this-&gt;cur_page * $this-&gt;per_page; $attributes = sprintf('%s %s=\"%d\"', $this-&gt;_attributes, $this-&gt;data_page_attr, $this-&gt;cur_page + 1); $output .= $this-&gt;next_tag_open.'&lt;a onclick='.$ci_pagination_id.'('.$this-&gt;prefix.$i.$this-&gt;suffix.','.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes .$this-&gt;_attr_rel('next').'&gt;'.$this-&gt;next_link.'&lt;/a&gt;'.$this-&gt;next_tag_close; &#125; // Render the \"Last\" link if ($this-&gt;last_link !== FALSE &amp;&amp; ($this-&gt;cur_page + $this-&gt;num_links + ! $this-&gt;num_links) &lt; $num_pages) &#123; $i = ($this-&gt;use_page_numbers) ? $num_pages : ($num_pages * $this-&gt;per_page) - $this-&gt;per_page; $attributes = sprintf('%s %s=\"%d\"', $this-&gt;_attributes, $this-&gt;data_page_attr, $num_pages); $output .= $this-&gt;last_tag_open.'&lt;a onclick='.$ci_pagination_id.'('.$this-&gt;prefix.$i.$this-&gt;suffix.','.json_encode($ci_pagination_id).'); href=\"javascript:void(0)\"'.$attributes.'&gt;' .$this-&gt;last_link.'&lt;/a&gt;'.$this-&gt;last_tag_close; &#125; // Kill double slashes. Note: Sometimes we can end up with a double slash // in the penultimate link so we'll kill all double slashes. $output = preg_replace('#([^:\"])//+#', '\\\\1/', $output); // Add the wrapper HTML if exists return $this-&gt;full_tag_open.$output.$this-&gt;full_tag_close; &#125;&#125;","tags":[{"name":"CI","slug":"CI","permalink":"http://yoursite.com/tags/CI/"}]},{"title":"使用mongoDB（三）——聚合","date":"2017-08-31T03:25:21.000Z","path":"2017/08/31/使用mongoDB（三）——聚合/","text":"这里我遇到一个问题：想要统计某一个人在某天一共发了多少个帖子。师兄让我研究一下聚合，我发现这个确实节约了不少时间~用mongo的聚合，我可以轻松聚合出一个人在同一天发了多少帖子∠( ᐛ 」∠)＿ 管道概念管道是由一个个功能节点组成的。聚合管道以一个集合中的所有文档作为开始，然后这些文档从一个操作节点流向下一个节点，每个操作节点对文档做相应的操作。这些操作可能会创建新的文档或者过滤掉一些不符合条件的文档，在管道中可以对文档进行重复操作。 管道基本的功能一是对文档进行“过滤”，也就是筛选出符合条件的文档;二是对文档进行“变换”，也就是改变文档的输出形式。 管道操作符管道操作符的种类： Name Description $project 重塑一个文档流。$project可以重命名、添加或删除字段，以及创建计算的值和子文档 $match 过滤文档流，只允许匹配的文档传递到下一个管道阶段。$match使用标准的MongoDB查询。 $skip 从管道中跳过指定数量的文档并返回其余的文档 $group 将文档组合在一起，用于计算基于文档集合的聚合值 $sort 获取所有输入文档并将它们返回到已排序的文档流中 管道操作符详细使用说明1. $project数据投影，主要用于重命名、增加和删除字段例如：12345678db.article.aggregate( &#123; $project : &#123; title : 1 , author : 1 , &#125; &#125;); 这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以加上:1_id : 0 , 除此之外使用$project还可以重命名字段名和子文档的字段名: 12345678910111213db.article.aggregate( &#123; $project : &#123; title : 1 , stats : &#123; pv : &quot;$pageViews&quot;, foo : &quot;$other.foo&quot;, dpv : &#123; $add:[&quot;$pageViews&quot;, 10]&#125; #产生了一个子文档stats,里面包含pv,foo,dpv三个字段。 &#125; &#125; &#125;); 2.$match滤波操作，筛选符合条件文档，作为下一阶段的输入例如：1234db.articles.aggregate( [ &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ); 注意： 1.不能在$match操作符中使用$where表达式操作符。2.$match尽量出现在管道的前面，这样可以提早过滤文档，加快聚合速度。 3. $limit限制经过管道的文档数量 $limit的参数只能是一个正整数 例如：1db.article.aggregate(&#123; $limit : 5 &#125;); 4. $skip从待操作集合开始的位置跳过文档的数目 $skip的参数只能是一个正整数 例如：1db.article.aggregate(&#123; $skip : 5 &#125;); 5. $group对数据进行分组 例如：1db.article.aggregate(&#123; $group : &#123;_id : &quot;$author&quot;&#125;&#125;); 注意： ：1.$group的输出是无序的。2.$group操作目前是在内存中进行的，所以不能用它来对大量个数的文档进行分组。 6. $sort对文档按照指定字段排序 例如：1db.users.aggregate( &#123; $sort : &#123; age : -1, posts: 1 &#125; &#125;); 注意： ：1.如果将$sort放到管道前面的话可以利用索引，提高效率 日期类型聚合操作符1.ISODate$dayOfYear: 返回该日期是这一年的第几天。（全年366天）$dayOfMonth: 返回该日期是这一个月的第几天。（1到31）$dayOfWeek: 返回的是这个周的星期几。（1：星期日，7：星期六）$year: 返回该日期的年份部分$month： 返回该日期的月份部分（between 1 and 12.）$week： 返回该日期是所在年的第几个星期（between 0 and 53）$hour： 返回该日期的小时部分$minute: 返回该日期的分钟部分$second: 返回该日期的秒部分（以0到59之间的数字形式返回日期的第二部分，但可以是60来计算闰秒。）$millisecond：返回该日期的毫秒部分（between 0 and 999.）$dateToString： { $dateToString: { format: , date: } } %Y Year (4 digits, zero padded) 0000-9999%m Month (2 digits, zero padded) 01-12%d Day of Month (2 digits, zero padded) 01-31%H Hour (2 digits, zero padded, 24-hour clock) 00-23%M Minute (2 digits, zero padded) 00-59%S Second (2 digits, zero padded) 00-60%L Millisecond (3 digits, zero padded) 000-999%j Day of year (3 digits, zero padded) 001-366%w Day of week (1-Sunday, 7-Saturday) 1-7%U Week of year (2 digits, zero padded) 00-53 举个栗子 我们有如下的集合：1234567&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-01-01T08:15:39.736Z&quot;)&#125; 下面的聚合使用$dateToString返回日期字段作为格式化的字符串:12345678910db.sales.aggregate( [ &#123; $project: &#123; yearMonthDay: &#123; $dateToString: &#123; format: &quot;%Y-%m-%d&quot;, date: &quot;$date&quot; &#125; &#125;, time: &#123; $dateToString: &#123; format: &quot;%H:%M:%S:%L&quot;, date: &quot;$date&quot; &#125; &#125; &#125; &#125; ]) 再来一个聚合栗子 ： 1234567db.getCollection(&apos;facebook_content_info&apos;).aggregate([&#123; $match : &#123;&apos;user_name&apos; :&apos;王大陸&apos;&#125;&#125;,&#123; $project : &#123;date: &#123; $dateToString: &#123; format: &quot;%Y-%m-%d&quot;, date: &quot;$created_time&quot; &#125; &#125;&#125;&#125;,&#123; $group: &#123; _id: &apos;$date&apos;, count: &#123; $sum: 1 &#125; &#125; &#125;,&#123;$sort:&#123;_id:1&#125;&#125;]); 2.string 的date直接用substr切分 聚合栗子 ： 123456789101112db.getCollection(&apos;case&apos;).aggregate([&#123; $match : &#123; $and: [&#123;&apos;case_basic.time&apos; : &#123; $gt : &apos;2017-06-23 9:32:44&apos; &#125;&#125;,&#123;&apos;case_basic.case_status&apos; :&apos;已归档&apos;&#125;]&#125;&#125;,&#123; $project : &#123; &apos;date&apos; : &#123;&apos;$substr&apos;:[&quot;$case_basic.time&quot;,0,10]&#125;&#125;&#125; ,&#123; $group: &#123; _id: &apos;$date&apos;, count: &#123; $sum: 1 &#125; &#125; &#125;,&#123; $project : &#123; &apos;_id&apos; : &apos;1&apos;, &apos;total&apos;: &apos;$count&apos;&#125;&#125; ,&#123; $group: &#123; _id: &apos;$_id&apos;, count: &#123; $sum: &apos;$total&apos; &#125; &#125; &#125;,]); 其他管道操作符在match中，我们可能联合算数类型操作符“$and”比较类型操作符“$gt,$lt,$gte,$lte” 在进行比较复杂的聚合操作时，可以先在mongo中操作一下，然后在转化成对应的phpmongo中一个{}或者[],写在php中就是一个array（） 举个栗子123456789101112131415161718192021222324public function line_weibo($last7days) &#123; $c=$this-&gt;db-&gt;weibo_messages; $ops=array( array( '$match'=&gt;array('Time_Pub' =&gt; array('$gt' =&gt; $last7days)) ), array( '$project'=&gt;array( 'date' =&gt; array('$dateToString' =&gt; array('format' =&gt; \"%Y-%m-%d\",'date' =&gt; '$Time_Pub'))) ), array( '$group'=&gt;array( '_id'=&gt;'$date', 'count'=&gt;array('$sum'=&gt;1) ) ), array('$sort'=&gt;array( \"_id\"=&gt;1) ) ); $results=$c-&gt;aggregate($ops); return $results;&#125; 其他要suo的话在聚合了之后，mongo会自动把有的一起聚合在一个，但是没有的就不会管啦！但是我们有的数据是需要连续的，这时候我们就只能自己循环，把没有的数据置为0 1234567891011121314151617public function line_twitter()&#123; $datelist=array(); $datalist=array(); for($i=0,$z=6; $i&lt;7; $i++,$z--)&#123; $date = date('Y-m-d', strtotime('-'.$z.' day')); array_push($datelist,$date); #把日期存到datelist数组中 array_push($datalist,0); #把所有的datalist置为0 for($j=0; $j&lt;count($total['result']); $j++)&#123; if ($date == $total['result'][$j]['_id']) &#123; $datalist[$i]=$total['result'][$j]['count']; &#125; &#125; &#125; $temp=array(\"date\"=&gt;$datelist,\"data\"=&gt;$datalist); #为了适合echarts构造数组 return $temp;&#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"使用mongoDB（二）——CI中用mongo实现增删改查","date":"2017-07-17T14:55:12.000Z","path":"2017/07/17/使用mongoDB（二）——CI中用mongo实现增删改查/","text":"安装好环境之后就要使用mongodb，先从简单的增删改查开始~ tips：用前人写好的类库会节省不少时间！ http://intekhab.in/mongodb-library-for-codeigniter.html 连接mongodb已经写好了，只需要配置就好了需要的增删改查里面都有，而且都贴心的附上了小栗子 安装方法1.将 mongodb.php 放到config目录。2.将 Mongo_db.php 放到library目录。 使用方法1.首先在controller控制器中引入mongodb.php1$this-&gt;load-&gt;library(&apos;Mongo_db&apos;); 2.在models中使用举个栗子：↓↓↓123456789$order_by = ['id' =&gt; -1];$where = ['status' =&gt; 1];$res = $this-&gt;mongo_db -&gt;select($fields) -&gt;order_by($order_by) -&gt;limit(21) -&gt;where_between('time_stamp', $start_date, $end_date) -&gt;where($where) -&gt;get('table_name'); 其他有时候类库并没有我们需要的函数，比如聚合，我们就需要自己写这时候我们就不能继续用$res = $this-&gt;mongo_db我们就要自己新连接数据库然后在进行相应的操作 连接1234567$conn = new MongoClient(); #默认本地的连接$conn = new MongoClient(\"mongodb://服务器地址:27017\"); #其他链接，默认端口号是27017$db = $conn-&gt;db; #选择名为db的数据库$db=$conn-&gt;selectDB(\"mydb\"); #第二种写法$collection = $db-&gt;collection #选择一个数据库表（集合）$collection=$db-&gt;selectCollection('column'); #第二种写法$collection=$conn-&gt;mydb-&gt;column; #更简洁的写法 查询123$data = $collection-&gt;find(array('name'=&gt;'goudan','ip'=&gt;'192.168.1.1'));$data = $collection-&gt;find(array('age'=&gt;array('$gt'=&gt;20,'$lt'=&gt;80)));$data = $collection-&gt;findOne();#查询一条结果 $gt为大于、$gte为大于等于、$lt为小于、$lte为小于等于、$ne为不等于、$exists不存在； 查询结果处理查询结果返回的是MongoCursor，是mongo的游标，一般使用foreach即可读取里面的数据 12345foreach($data as $key =&gt; $value)&#123; var_dump($key); var_dump($value); ....&#125; 但是我们更习惯使用数组，就可以使用 iterator_to_array() 将游标转换成一个数组。 123$cursor = $collection-&gt;find();$array = iterator_to_array($cursor);这样输出的则是数组类型的。 【注】使用 iterator_to_array() 会让驱动将强制载入所有搜索结果集到内存，所以对超过内存大小的结果集不要这么做 mongodb数据格式 mongodb获取的时间是时间戳格式我们要进行相应的转化 mongodb自带的’_id’是object，也要进行相应的转换 1.日期1234567891011121314151617181920#MongoDate类型格式如下：[timestamp] =&gt; MongoDate Object( [sec] =&gt; 1379495520 #表当前时间 [usec] =&gt; 0 #时间精确到微秒 )#转化时间$timestamp = date(\"Y-m-d H:i\", $start-&gt;sec); #start使我们获取到的时间 /*创建MongoDate类型*/$start = new MongoDate($startRaw); #创建MongoDate类型，$startRaw可为时间戳类型#如：$start = new MongoDate(strtotime('2016-4-7 12:00:00'));$end = new MongoDate(strtotime('2016-4-8 12:00:00'));/*查询某个时间段内的数据*/$time=$collection-&gt;find(array('timestamp'=&gt;array('$gt'=&gt;$start,'$lte'=&gt;$end))) /*查询一星期内的数据*/$lastweek = new MongoDate(strtotime('-1 week')); $data = $collection-&gt;find(array('timestamp' =&gt; array('$gt' =&gt; $lastweek))); 2.id 12345678/*使用下面的方法来匹配&#123;\"_id\":ObjectId(\"56df8bbed7bc8d047cc7dfa7\")&#125;查询、更新也一样$id = new MongoId(\"56df8bbed7bc8d047cc7dfa7\");$data = $collection-&gt;find(array('_id'=&gt;(object)$id));或者$data = $collection-&gt;find(array('_id'=&gt;$id)); 删除12$collection-&gt;remove(array(\"title\"=&gt;\"MongoDB 教程\"), array(\"justOne\" =&gt; true));//remove中的代表的是筛选条件 修改123456$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;testcollection; // 选择集合// 更新文档$collection-&gt;update(array(\"title\"=&gt;\"MongoDB\"), array('$set'=&gt;array(\"title\"=&gt;\"MongoDB 教程\")));//在update里的第一个选项代表筛选'title'为'MongoDB'的数据 将‘title‘更新为’MongoDB教程‘； 添加123456789$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;testcollection; // 选择集合$document = array( \"title\" =&gt; \"MongoDB\", \"description\" =&gt; \"database\");$collection-&gt;insert($document);echo \"数据插入成功\";；","tags":[{"name":"CI","slug":"CI","permalink":"http://yoursite.com/tags/CI/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"使用mongoDB（一）——准备工作","date":"2017-07-17T14:41:09.000Z","path":"2017/07/17/使用mongoDB（一）——准备工作/","text":"啊！！！生活不只有眼前的mysql，还有mongodb和远方……φ(&gt;ω&lt;*)这次需要从mongoDB中读取数据，那就重头开始学ㄟ( ▔, ▔ )ㄏ Windows安装mongoDB下载安装根据你的系统下载 32 位或 64 位的 .msi 文件，下载后双击该文件，按操作提示安装即可。 配置安装配置存放日志和数据的目录 添加MongoDB到Windows Service我们当我们把运行MongoDB服务器的dos命令界面关掉，这样我们就不能链接MongoDB，我们需要像MySQL那样，添加到Windows Service，然后在命令行上启动服务和关闭服务，这样方便我们操作和管理服务。使他开机自启 友情链接【学习MongoDB 一：MongoDB入门（安装与配置）】http://blog.csdn.net/congcong68/article/details/44277469 安装mongo客户端安装好了mongoDB的客户端仅仅只能用命令行展示数据，要用一个好用的客户端来展示数据方便操作~我用的robomongo 安装php mongodb扩展查看php型号你需要知道自己的php是什么样型号，在phpinfo()中查看 我的是php 5.6.25,64位，线性安全的 下载扩展然后我们到mongo扩展下载页面看http://pecl.php.net/package/mongo 然后下载对应的版本 复制php_mongo.dll到相应文件夹下载好以后解压文件 然后把php_mongo.dll这个文件导入到“wamp\\bin\\php\\php5.6.25\\ext”这个路径的文件夹下面注意！！！ 这里一定要放到../ext 这个文件夹下面！！！！！放错了就不好使！！！！ 修改php.ini然后打开并修改php配置文件 php.ini wamp在“wamp64\\bin\\php\\php5.6.25”中找php.ini在“wamp64\\bin\\apache\\apache2.4.23\\bin”中找php.ini添加以下配置：【我在php还有apache下面都修改了这个php.ini】 最好找到“extension=……”这个大部队在后面添加这句话 xampp在控制面板中点击Apache的config，选择php.ini添加以下配置：【我在php还有apache下面都修改了这个php.ini】 最好找到“extension=……”这个大部队在后面添加这句话 1extension=php_mongo.dll 查看安装成功与否最后一步！！！！重启WAMP或者XAMPP，然后进phpinfo()里面查看！你就神奇的发现！！！大功告成了！！！٩(๑&gt;◡&lt;๑)۶ 友情链接【php mongodb扩展安装】http://syean.cn/2016/04/06/php-mongodb%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85/【MongoDBPHP 扩展】http://www.jianshu.com/p/2c53e201ba84","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"模板使用心得","date":"2017-03-10T08:05:23.000Z","path":"2017/03/10/模板使用心得/","text":"在CI框架中，利用one ui模板自己搭建一个自己想要的界面。o(*≧▽≦)ツ期间我遇见很多问题，ಥ_ಥ 马克一下我自己翻越的小山和摔过的坑。 侧边栏问题1.侧边栏高亮问题 &emsp; 解决办法 ：在inc文件下的config.php文件里面 12$one-&gt;main_nav_active = get_basename($_SERVER['PHP_SELF']);// var_dump($one-&gt;main_nav_active); var_dump看$one-&gt;main_nav_active出来是什么然后在对应的url上添加一个urlc 123456array( 'name' =&gt; '&lt;span class=\"sidebar-mini-hide\"&gt;用户列表&lt;/span&gt;', 'icon' =&gt; 'fa fa-list', 'urlc' =&gt; 'userlist_weibo', 'url' =&gt; '/weibo/userlist_weibo'), 最后改变在inc文件下的views文件夹里面的Template.php文件里面的 1$link_active = $link_urlc == $this-&gt;main_nav_active ? true : false; 2.不同用户看到的侧边栏不同 &emsp; 解决办法 ：在inc文件下的config.php文件里面 ，创建多个Menu 然后修改inc文件下的class文件夹里面的Template.php文件里面的build_nav函数12345678910111213141516171819202122232425/** * Builds main navigation * * @param boolean $print True to print the navigation and False to return it * * @return string Returns the navigation if $print is set to false */public function build_nav($print = true) &#123; // Build navigation $role=$_SESSION['role']; //echo $_SESSION['username']; if($role==\"admin\")&#123; $this-&gt;build_nav_array($this-&gt;main_nav_admin); &#125; if ($role==\"common\") &#123; $this-&gt;build_nav_array($this-&gt;main_nav_common); &#125; // Print or return navigation if ($print) &#123; echo $this-&gt;nav_html; &#125; else &#123; return $this-&gt;nav_html; &#125;&#125; 入口文件问题修改默认入口文件，默认情况下是welcome.php 解决办法1.直接修改welcome里面的东西，改成自己想要的。2.修改config文件夹里面的routes.php p.s：在添加了登录页面之后，默认入口文件应该是主页的控制器文件！！！ session过期问题登录系统后短时间退出系统再进不需要登录，如果session过期，则跳转到login界面重新登陆 解决办法在控制器的构造函数里加上if(!$this-&gt;session-&gt;userdata(‘login’)){header(‘location:http://&#39;.base_url().&#39;login&#39;);} 12345678910public function __construct()&#123; parent::__construct(); if(!$this-&gt;session-&gt;userdata('login'))&#123;header('location:http://'.base_url().'login');&#125; $this-&gt;load-&gt;library('Mongo_db'); $this-&gt;load-&gt;library('pagination'); $this-&gt;load-&gt;library('MY_Pagination'); $this-&gt;load-&gt;model('twitter/userpage_twitter_m');&#125; 路径问题缺少js,css 仔细检查资源文件，看看路径哪错了 加/,从项目根目录出发 不加/,从当前目录出发 数据库问题 配置application文件夹里面的config.php文件夹里面的autoload.php 对$autoload[‘libraries’] 1$autoload['libraries'] = array('database', 'session');","tags":[{"name":"CI框架","slug":"CI框架","permalink":"http://yoursite.com/tags/CI框架/"}]},{"title":"vue学习笔记（一）","date":"2017-03-02T11:40:41.000Z","path":"2017/03/02/vue学习笔记（一）/","text":"Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。 Vue是一个mvvm框架(库)。指令以v-xxx为结构一段html代码 加一个json 再new出一个vue实例 vue基本结构 要求：展示一条数据 html： 123&lt;div id=&quot;box&quot;&gt; &#123;&#123;msg&#125;&#125; //vue里面的数据用两个大括号表示 &#123;&#123;数据&#125;&#125;&lt;/div&gt; js： 123456789101112131415 var c = new Vue(&#123; //new一个Vue的对象 可以不写“var c = ”，直接new el:'#box', //选择器，和jquery一样，让vue挂载在一个元素上面 data:&#123; //data里可以放字符串，json ，数组， 布尔，数字 msg:'document' , //要展示的数据内容 num:12, bool:true, myData:[], ....... &#125;， methods:&#123; get()&#123; //get方法 &#125; &#125;&#125;); 注意： 这里的c是可以任意起名的，也可以不写，不写的话调用的时候就是this。比如想要拿到里面的num的值，可以这样 this.data.num vue常用指令1. v-model 一般放在表单元素上(input、textarea) –&gt; 双向数据绑定 html：1234&lt;div id=\"box\"&gt; &lt;input type=\"text\" v-model=\"msg\" /&gt; &lt;p&gt;Message is: &#123;&#123; msg &#125;&#125;&lt;/p&gt; //msg是vue对象里面的data数据&lt;/div&gt; js： 123456new Vue(&#123; el: '#box', data: &#123; msg: hello &#125;&#125;) 还可以用于复选框，按钮，多选，单选按钮 html: 12345678910&lt;div id='example-3'&gt; &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; js:1234567new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;)多个复选框，绑定到同一个数组： 2.v-for 循环数组数组语法 &emsp;&emsp;value in arr &emsp;&emsp;(value, index) in arr对象语法 &emsp;&emsp;value in obj &emsp;&emsp;(value, key) in obj &emsp;&emsp;(value, key, index) in obj 3.v-on:click=”函数” 事件语法:v-on:click/mouseout/mouseover/dblclick/mousedown….. v-on:click=”show()” 一般是这样@click=”show()” 这是简写 建议用”@click=’函数’” //这里click是触发函数的条件 html:123&lt;div id='example-3'&gt; &lt;button @click=\"事件\"&gt;提交&lt;/button&gt;&lt;/div&gt; js：1234methods:&#123; //事件放到methods里 事件名:function()&#123; //可以直接写成 事件名 ()&#123;&#125; alert(1); &#125; 事件对象：$event定死的，必须有$@click(show($event)) 123456methods:&#123; show:function(ev,n)&#123; alert(ev.clientX); alert(n);//n也可以拿到 &#125;&#125; 在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符键盘事件：@keydown $event ev.keyCode@keyup 常用键: &emsp;&emsp;回车 &emsp;&emsp;a). @keyup.13 &emsp;&emsp;b). @keyup.enter &emsp;&emsp;上、下、左、右 &emsp;&emsp;@keyup/keydown.left &emsp;&emsp;@keyup/keydown.right &emsp;&emsp;@keyup/keydown.up &emsp;&emsp;@keyup/keydown.down html:12345678&lt;div id='example-3'&gt; &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.13=\"submit\"&gt; &lt;!-- 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：上 --&gt; &lt;input v-on:keyup.enter=\"submit\"&gt; &lt;!-- 缩写语法 --&gt; &lt;input @keyup.enter=\"submit\"&gt;&lt;/div&gt; 全部的按键别名： &emsp;&emsp;.enter &emsp;&emsp;.tab &emsp;&emsp;.delete (捕获“删除”和“退格”键) &emsp;&emsp;.esc &emsp;&emsp;.space &emsp;&emsp;.up &emsp;&emsp;.down &emsp;&emsp;.left &emsp;&emsp;.right可以通过全局 config.keyCodes 对象自定义按键修饰符别名：12// 可以使用 `v-on:keyup.f1` Vue.config.keyCodes.f1 = 112 v-show 显示/隐藏v-show=’true/false’; true是显示 false是隐藏 true和false可以是data里面的数据 v-bind 属性动态地绑定一个或多个特性，或一个组件 prop 到表达式。v-bind:src=””&emsp;&emsp;&emsp; width/height/title…. html:1&lt;img :src=\"url\" id=\"img\" :width='a'/&gt; 特殊属性:class&amp;style&emsp;&emsp;:class=”” v-bind:class=””&emsp;&emsp;:style=”” v-bind:style=”” 1. class1). &emsp;:class=[red,blue] //对应的是数据1234data&#123; red:'red', blue'blue'&#125; 2). &emsp;:class=”{red:a,blue:b}” //对应的是 类名和数据1234data&#123; a:true, b:false&#125; 3). &emsp;:clsss=”json”; //也可以吧json直接写到数据里，看起来更舒服-推荐123456data&#123; json:&#123; red:true, blue:false &#125;&#125; 2. style1). &emsp;:styel=[c,d];/.每一个样式都是一条json 1234567891011121314151617181920212223242526272829303132data:&#123; c:&#123;color:'red'&#125;, d:&#123;backgroundColor:'blue'&#125;//复合样式用驼峰命名法&#125;``` 2). &amp;emsp;:style=&#123;json&#125;;```javascriptdata:&#123; json&#123; color:\"red\", background:\"blue\" &#125;&#125;``` ## 组件每一个模块其实就是一个组件&lt;img src=\"http://oz2sm5hay.bkt.clouddn.com/vue-%E7%BB%84%E4%BB%B6.png\"&gt;&gt; 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例#### 1. 全局组件&gt; 要注册一个全局组件，可以使用 Vue.component(tagName, options)。组件在注册之后，便可以作为自定义元素 &lt;todo-item&gt;&lt;/todo-item&gt; 在一个实例的模板中使用。 注意确保在初始化根实例之前注册组件： html:```html&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; js:123456789// 注册名为 my-component 的新组件Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 最后html被渲染成：123&lt;div id=\"example\"&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 2.局部组件12345678var vm=new Vue(&#123; el:&apos;#box&apos;, components:&#123; &apos;my-aaa&apos;:&#123; template:&apos;&lt;h2&gt;标题2&lt;/h2&gt;&apos; &#125; &#125;&#125;); 组件的注意事项：组件里面的data必须是一个函数12345678Vue.component('my-component', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;&#125;) 3.模板一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。1). 组件只只有一句html1template:&apos;&lt;h2 @click=&quot;change&quot;&gt;标题2-&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&apos; 2). 组件里面html比较多，单独放到某个地方【放在vue挂载的元素之外】12345678&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;val in arr&quot;&gt; &#123;&#123;val&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; HTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)： 12345Vue.component('child', &#123; // 在 JavaScript 中使用 camelCase props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;) 12&lt;!-- 在 HTML 中使用 kebab-case --&gt;&lt;child my-message=\"hello!\"&gt;&lt;/child&gt; 如果你使用字符串模板，则没有这些限制。 所谓字符串模板就是在js的template:””写的html。JavaScript内联模版字符串。非字符串就是在html中&lt;?template&gt;里面的内容 4.父子组件传参 vue里面父子组件不能直接传参 1). 子组件使用父组件的数据我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件： 在调用子组件： 子组件之内: props:[‘m’,’myMsg’] //数组里面是父组件数据的名称 12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 2). 父组件使用子组件的数据父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 子组件把自己的数据，发送到父级 vm.$emit(事件名,数据); 举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;父子组件&lt;/title&gt; &lt;script src='vue.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &lt;father&gt; &lt;span slot=\"father\"&gt; //插槽 我自己有话要说！！！&lt;br&gt; &lt;/span&gt; &lt;/father&gt; &lt;/div&gt; &lt;template id=\"father\"&gt; &lt;div style=\"color:red\"&gt;&lt;slot name=\"father\"&gt;&lt;/slot&gt; //&lt;slot&gt; 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。 我是你&#123;&#123;msg1&#125;&#125;--&gt;&#123;&#123;sonData&#125;&#125; &lt;son :name='msg1' :my-message='msg2' @myson=\"get\"&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=\"son\"&gt; &lt;div style=\"color:green\"&gt;你是我&#123;&#123;name&#125;&#125;&lt;br&gt;&#123;&#123;myMessage&#125;&#125;&lt;br&gt;&lt;button @click=\"send()\"&gt;biu&lt;/button&gt;&lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:\"#box\", components:&#123; 'father':&#123; template:'#father', data()&#123; return &#123; msg1:\"粑粑\", msg2:'❤', sonData:'' &#125; &#125;, methods:&#123; get(msg)&#123; this.sonData=msg; &#125; &#125;, components:&#123; 'son':&#123; props:['name','myMessage'], data()&#123; return &#123; sonMsg:\"儿子的话\" &#125; &#125;, methods:&#123; send()&#123; this.$emit('myson',this.sonMsg); &#125; &#125;, template:'#son' &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Hexo搭建Github静态博客","date":"2017-02-09T02:21:23.000Z","path":"2017/02/09/hexo搭建博客/","text":"hexo是一款基于Node.js的静态博客框架 (●°u°●)​ 」这是一篇小白教程Hexo搭建Github静态博客。 1.安装准备工作1.1 安装Git1.2 安装node.js下载：http://nodejs.org/download/可以下载 node-v0.10.33-x64.msi安装时直接保持默认配置即可。下载完成后可以同时按下Win键和R键打开运行窗口,输入”cmd,然后输入以下命令123git --versionnode -vnpm -v 我们要用到npm，但是npm可能很慢，可以安装npm的镜像，cnpm。安装好以后所有的npm命令都可以把npm换成cnpmcnpm 安装代码：1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 2.配置Github2.1 建立Repository建立与你用户名对应的仓库,仓库名必须为[your_user_name.github.io] 2.2 配置SSH-Key详情见网上的教程 3.安装Hexo关于Hexo的安装配置过程,请以官方给出的步骤为准。 3.1 Installation随便找个地方(我是桌面)右键打开Git Bash打开Git命令行,执行如下命令1$ npm install -g hexo-cli 3.2 Setup一旦Hexo安装好了,我们选择一个地方来传建项目:),新建文件夹(我取名叫blog),在这个文件夹里右键打开Git Bash执行如下命令1$ hexo init Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install1npm install 会在你选择的路径中安装 node_modules。 3.3 Start the server接着运行下面的命令1$ hexo server 然后在浏览器中打开 http://localhost:4000/这时可以看到Hexo已为你生成了一篇blog。你可以按Ctrl+C 停止Server。 3.4 Create a new post在博客文件夹里新打开一个git bash命令行窗口，执行下面的命令1$ hexo new \"My New Post\" //\"My New Post\"是新文章的名字 刷新http://localhost:4000/，可以发现已生成了一篇新文章 “My New Post”。 3.5 Generate static files执行下面的命令，将markdown文件生成静态网页。1$ hexo generate //简写为$ hexo g 该命令执行完后，会在 博客目录\\public\\ 目录下生成一系列html，css等文件。 3.6 编辑文章hexo new “My New Post”会在 博客目录\\source_posts目录下生成一个markdown文件：My-New-Post.md可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。 3.7 部署到Github首先安装hexo-deployer-git.1$ npm install hexo-deployer-git --save 接着配置博客文件下的_config.yml文件，首先找到下面的内容修改123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: github repository: git@github.com:Github名称/仓库名.github.io.git branch: master 3.8 成功啦ʕ •ᴥ•ʔ每次部署的步骤，可按以下三步来进行。123$ hexo clean$ hexo generate$ hexo deploy 基本可以简化为1$ hexo d -g 4.配置4.1安装主题Hexo提供了很多主题，详见https://www.zhihu.com/ question/24422335 选择自己喜欢的主题，这里我选择了litten/hexo-theme-yilia。(￣(工)￣)使用Hexo更换主题还算方便，先使用克隆命令安装好主题，然后更改一下博客的配置文件_config.yml里面的主题名称就好了。1.在博客目录下右键点击Git Bash，输入以下命令。1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载好的主题都在这里：修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 Attention:插入图片最好用网络图片∠( ᐛ 」∠)＿ 先把图片上传到贴图库，然后复制Markdown就可以啦！ 到这里基本就大功告成了！！U^ェ^U，现在就是学习Markdown语句就可以写一篇自己的博客了 友情链接：网上写的比较好的两篇教程http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#写博客http://www.cnblogs.com/zhcncn/p/4097881.html","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]